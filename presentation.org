#+STARTUP: showeverything
#+OPTIONS: ^:{}

#+OPTIONS: reveal_title_slide:nil
#+OPTIONS: reveal_slide_number:nil
#+OPTIONS: reveal_progress
#+OPTIONS: num:nil 
#+REVEAL_HLEVEL:1
#+REVEAL_PLUGINS: (highlight)
#+REVEAL_THEME: black
#+REVEAL_TRANS: none

* solid

** solid
- SRP (single responsibility principle)
- OPC (open close principle)
- LSP (liskov substitution principle)
- ISP (interface segregation principle)
- DIP (dependency inversion principle)

** what is it good for?
- fundamental principles of softwaredesigns
- common sense

** why should you care?
you can solve problems without knowing these principles

** heuristic
file:labyrinth.gif

#+BEGIN_NOTES
Bezeichnet die Kunst, mit begrenztem Wissen und wenig Zeit zu guten Lösungen zu kommen.
Für die Lösung eines Problems in Software gibt es unendlich viele Möglichkeiten, aber nicht alle sind gleich gut.
Die Prinzipien helfen uns dabei unmögliche und schlechte Lösungen auszuschließen.
Sie sind quasi wie Wegweiser durch ein Labyrinth.
#+END_NOTES

** file:treppe_gegen_wand.jpg

** file:treppe_bei_draeger.jpg

* single responsibility
one module, one responsibility
module = package, file, class, method

** file:srp_hacker.jpg
#+BEGIN_NOTES
Hackerreflex unterdrücken!!!
Nachdenken!
Bei jeder neuen Klasse als erstes einen Kommentar, der die Verantwortlichkeit beschreibt!
Vielleicht brauche ich die Klasse auch gar nicht!
Design zeichnen (muss nicht UML sein)
#+END_NOTES

** responsibilities
#+BEGIN_SRC plantuml :file srp_01.png
class addressbook {
      +add()
      +remove()
      +compress()
      +decompress()
}

note right of addressbook
    maintains a list of addresses
    which can be added or removed and
    allows to compress/decompress
    the whole collection
end note

#+END_SRC

#+RESULTS:
[[file:srp_01.png]]

** responsibilities
#+BEGIN_SRC plantuml :file srp_02.png
class addressbook {
      +add()
      +remove()
}

class addressbook_compressor {
      +compress()
      +decompress()
}

addressbook_compressor --> addressbook

note bottom of addressbook
    maintains a list of addresses
    which can be added or removed
end note

note bottom of addressbook_compressor
    compress/decompress
    the whole collection
end note

#+END_SRC

#+RESULTS:
[[file:srp_02.png]]

** srp violations
-  how easy it is to find a catchy name for the module?
- are the ands or ors in the comment?
- module has to be changed for more than one reason?
- low cohesion?

** cohesion
#+BEGIN_SRC plantuml :file cohesion_01.png
class address

class rar_compressor

class addressbook

addressbook --> address
addressbook --> rar_compressor

note left of addressbook
    m_addresses.add(addr);
    m_addresses.remove(addr);
end note

note right of addressbook
    m_compressor.compress();
    m_compressor.decompress();
end note

#+END_SRC

#+RESULTS:
[[file:cohesion_01.png]]

#+BEGIN_NOTES
Werden alle Member in allen Methoden verwendet?

Verantwortlichkeit – schwammiger Begriff
Kohäsion – überprüfbar (ursprünglich hieß Prinzip Kohäsion (Tom De Marco))

100% SRP – prozedualer Code (toString, toHtml, toCsv, …)
#+END_NOTES

** coherent unit
#+BEGIN_SRC plantuml :file cohesion_02.png
interface startable {
    +start()
}

interface stopable {
    +stop()
}
#+END_SRC

#+RESULTS:
[[file:cohesion_02.png]]

#+BEGIN_NOTES
Kein SRP, da start und stop zusammengehören (eine hohärente Gruppe bilden)
#+END_NOTES

* interface segregation
client should not depend on details not needed

** cohesion
#+BEGIN_SRC plantuml :file cohesion_03.png
interface addressbook {
    +add()
    +remove()
    +compress()
    +decompress()
}

class compress_controler

class mail_client

compress_controler --> addressbook
mail_client --> addressbook

note left of compress_controler
    m_addressbook.compress()
    m_addressbook.decompress()
end note

note right of mail_client
    m_addressbook.add(addr)
    m_addressbook.remove(addr)
end note
#+END_SRC

#+RESULTS:
[[file:cohesion_03.png]]

#+BEGIN_NOTES
Kohäsion bezieht sich auf die Anzahl der Schnitstellen die von einem Klienten benutzt werden.
Benutzt der Klient alle Schnittstellen ist die Kohäsion hoch, ansonsten niedrig.
#+END_NOTES

** cohesion
#+BEGIN_SRC plantuml :file cohesion_04.png
interface addressbook {
    +add()
    +remove()
}

interface compressable {
    +compress()
    +decompress()
}

class compress_controler

class mail_client

compress_controler --> compressable
mail_client --> addressbook

note left of compress_controler
    m_addressbook.compress()
    m_addressbook.decompress()
end note

note right of mail_client
    m_addressbook.add(addr)
    m_addressbook.remove(addr)
end note
#+END_SRC

#+RESULTS:
[[file:cohesion_04.png]]

#+BEGIN_NOTES
Geringere Abhängigkeiten
Losere Kopplung

C++ hält sich nicht dran. Privates sind im Header!
#+END_NOTES

** realizing srp with isp
#+BEGIN_SRC plantuml :file srp_with_isp.png
interface addressbook {
    +add()
    +remove()
}

interface compressable {
    +compress()
    +decompress()
}

class addressbook_impl

compressable <|-- addressbook_impl
addressbook <|-- addressbook_impl
#+END_SRC

#+RESULTS:
[[file:srp_with_isp.png]]

#+BEGIN_NOTES
Schnittstelle ist wichtiger als Implementierung
C++ Interfaces private implementieren
#+END_NOTES


* Uncle Bob
- clean code book
- clean code kino
